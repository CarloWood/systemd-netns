#! /bin/bash

# Run this script to update the symbolic links regarding netns
# in /etc/systemd/system. This script also fixes a possible
# problem due to the bug https://github.com/systemd/systemd/issues/37329
# if any of the units is in a failed state, by reset that state.

# Exit on error, unset variable, or pipe failure.
set -euo pipefail

CONF_DIR="/etc/conf.d/netns"
SYMLINK_DIR="/etc/systemd/system"
TARGET_SERVICE_NETNS="/usr/lib/systemd/system/netns@.service"
TARGET_SERVICE_OUTSIDE="/usr/lib/systemd/system/netns_outside@.service"

# --- Sanity Checks ---

if [[ "$(id -u)" -ne 0 ]]; then
  echo "Error: This script must be run as root." >&2
  exit 1
fi

if [[ ! -d "$CONF_DIR" ]]; then
  echo "Error: Configuration directory '$CONF_DIR' not found." >&2
  exit 1
fi

if [[ ! -d "$SYMLINK_DIR" ]]; then
  echo "Error: Systemd system directory '$SYMLINK_DIR' not found." >&2
  exit 1
fi

if [[ ! -f "$TARGET_SERVICE_NETNS" ]]; then
  echo "Error: Target service file '$TARGET_SERVICE_NETNS' not found." >&2
  exit 1
fi
if [[ ! -f "$TARGET_SERVICE_OUTSIDE" ]]; then
  echo "Error: Target service file '$TARGET_SERVICE_OUTSIDE' not found." >&2
  exit 1
fi

# --- Process Configuration Files and Create Symlinks ---

# Use an associative array to keep track of the symlinks that *should* exist.
# Keys are the symlink basenames, values can be anything (e.g., 1).
declare -A expected_symlinks

echo "Processing configuration files in '$CONF_DIR'..."

# Use process substitution and null delimiters for safe filename handling.
while IFS= read -r -d $'\0' conf_file; do
  filename=$(basename "$conf_file")
  # Skip default.conf explicitly
  if [[ "$filename" == "default.conf" ]]; then
    continue
  fi

  # Extract NSTYPE (the part before .conf).
  nstype="${filename%.conf}"

  if [[ -z "$nstype" ]]; then
      echo "Warning: Could not extract NSTYPE from '$filename'. Skipping." >&2
      continue
  fi

  echo "Found NSTYPE: '$nstype'"

  # Define expected symlink names and paths.
  link_name_netns="netns-${nstype}@.service"
  link_path_netns="${SYMLINK_DIR}/${link_name_netns}"
  link_name_outside="netns_outside-${nstype}@.service"
  link_path_outside="${SYMLINK_DIR}/${link_name_outside}"

  # Add expected symlink names to our tracking array.
  expected_symlinks["$link_name_netns"]=1
  expected_symlinks["$link_name_outside"]=1

  # Ensure the first symlink exists (create or update).
  echo "  Ensuring symlink '$link_path_netns' -> '$TARGET_SERVICE_NETNS'"
  if ! ln -sf "$TARGET_SERVICE_NETNS" "$link_path_netns"; then
      echo "  Error creating/updating symlink '$link_path_netns'. Check permissions?" >&2
      # Continue processing other files despite error? Or exit? Let's continue.
  fi

  # Ensure the second symlink exists (create or update).
  echo "  Ensuring symlink '$link_path_outside' -> '$TARGET_SERVICE_OUTSIDE'"
  if ! ln -sf "$TARGET_SERVICE_OUTSIDE" "$link_path_outside"; then
      echo "  Error creating/updating symlink '$link_path_outside'. Check permissions?" >&2
      # Continue processing other files despite error? Or exit? Let's continue.
  fi

done < <(find "$CONF_DIR" -maxdepth 1 -type f -name '*.conf' -print0)

# --- Clean Up Stale Symlinks ---

echo "Cleaning up stale symlinks in '$SYMLINK_DIR'..."
needs_daemon_reload=false

# Find all symlinks in the target directory pointing to our specific service files.
find "$SYMLINK_DIR" -maxdepth 1 -type l \( -lname "$TARGET_SERVICE_NETNS" -o -lname "$TARGET_SERVICE_OUTSIDE" \) -print0 | while IFS= read -r -d $'\0' symlink_path; do
    symlink_name=$(basename "$symlink_path")

    # Check if the current symlink's basename is in our list of expected symlinks.
    if [[ ! -v expected_symlinks["$symlink_name"] ]]; then
        echo "  Removing stale symlink: $symlink_path"
        if rm "$symlink_path"; then
            needs_daemon_reload=true
        else
            echo "  Error removing symlink '$symlink_path'. Check permissions?" >&2
        fi
    # else # Optional: Log kept links.
    #   echo "  Keeping required symlink: $symlink_path"
    fi
done

# --- Reset Failed Units ---

echo "Checking for and resetting failed units..."
failed_units_found=false

# Use process substitution to read unit names safely.
while IFS= read -r unit_name; do
  # Skip empty lines potentially generated by awk/systemctl.
  [[ -z "$unit_name" ]] && continue

  failed_units_found=true
  echo "  Found failed unit: '$unit_name'. Resetting..."
  if systemctl reset-failed "$unit_name"; then
    echo "    Successfully reset '$unit_name'."
  else
    # Log error but continue; reset-failed might fail if state changed.
    echo "    Warning: Failed to reset '$unit_name'. It might no longer be in a failed state." >&2
  fi
done < <(systemctl list-units --all --no-legend --state=failed 'netns@*.service' 'netns_outside@*.service' | awk '{print $1}')

if ! $failed_units_found; then
    echo "  No relevant failed units found."
fi

# --- Final Steps ---

# Reload systemd daemon configuration if symlinks were removed.
# Creating/updating symlinks with ln -sf doesn't strictly require daemon-reload
# unless it affects unit dependencies or ordering, but removing definitely does.
if $needs_daemon_reload; then
    echo "Reloading systemd daemon configuration..."
    if systemctl daemon-reload; then
        echo "  Systemd daemon reloaded successfully."
    else
        echo "  Error reloading systemd daemon configuration." >&2
    fi
fi

echo "Script finished."
exit 0
